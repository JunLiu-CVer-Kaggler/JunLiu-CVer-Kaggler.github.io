### 双线性插值的几个问题分析

### [双线性插值](https://meghal-darji.medium.com/implementing-bilinear-interpolation-for-image-resizing-357cbb2c2722)
#### 源图像和目标图像几何中心的对齐 
解决方法：

在计算源图像的虚拟浮点坐标的时候，一般情况： 
- srcX=dstX* (srcWidth/dstWidth) , 
- srcY = dstY * (srcHeight/dstHeight) 

中心对齐(OpenCV也是如此)： 
- SrcX=(dstX+0.5)* (srcWidth/dstWidth) -0.5 
- SrcY=(dstY+0.5) * (srcHeight/dstHeight)-0.5

[双线性插值算法及需要注意事项](https://www.iteye.com/blog/handspeaker-1545126)这篇博客解释说“如果选择右上角为原点（0，0），那么最右边和最下边的像素实际上并没有参与计算，而且目标图像的每个像素点计算出的灰度值也相对于源图像偏左偏上。”
具体来说将公式变形，
- srcX=dstX* (srcWidth/dstWidth)+0.5*(srcWidth/dstWidth-1) 

相当于我们在原始的浮点坐标上加上了0.5*(srcWidth/dstWidth-1)这样一个控制因子，这项的符号可正可负，与srcWidth/dstWidth的比值也就是当前插值是扩大还是缩小图像有关，有什么作用呢？看一个例子：假设源图像是3*3，中心点坐标（1，1）目标图像是9*9，中心点坐标（4，4），我们在进行插值映射的时候，尽可能希望均匀的用到源图像的像素信息，最直观的就是（4,4）映射到（1,1）现在直接计算srcX=4*3/9=1.3333！=1，也就是我们在插值的时候所利用的像素集中在图像的右下方，而不是均匀分布整个图像。现在考虑中心点对齐，srcX=(4+0.5)*3/9-0.5=1，刚好满足我们的要求。

#### [将浮点运算转换成整数运算](https://www.cnblogs.com/Imageshop/archive/2011/11/12/2246808.html)
参考图像处理界双线性插值算法的优化 直接进行计算的话，由于计算的srcX和srcY 都是浮点数，后续会进行大量的乘法，而图像数据量又大，速度不会理想，解决思路是：浮点运算→→整数运算→→”<<左右移按位运算”。

放大的主要对象是u，v这些浮点数，OpenCV选择的放大倍数是2048“如何取这个合适的放大倍数呢，要从三个方面考虑：
1. 精度问题，如果这个数取得过小，那么经过计算后可能会导致结果出现较大的误差。
2. 这个数不能太大，太大会导致计算过程超过长整形所能表达的范围。
3. 速度考虑。假如放大倍数取为12，那么算式在最后的结果中应该需要除以12*12=144，但是如果取为16，则最后的除数为16*16=256，这个数字好，我们可以用右移来实现，而右移要比普通的整除快多了。”我们利用左移11位操作就可以达到放大目的。




